I give the C++ onboarding to new hires at Facebook. I, eventually, put in a bit of discussion at the top of every class where the slide reads simply "why C++" and the question is: let's say we are starting a new thing, what are the correct reasons to choose C++ vs some other language. I did this originally as a tactical move to give a safe (and well-timed) section where I could get all those arguments out of the way so we could get through the rest of the talk w/o getting hijacked. 

This has been a very enlightening cross section of programmer opinion. Different rooms have different personalities. Usually it's "use C++ because speed". Sometimes it's anti-C++ because "templates lol, just use C". Sometimes it's anti-C++ because "people are faster than machines, let's use python and 'drop down into C when we need speed". Sometimes it's pro-C++ "because garbage collection succcckkkkkksssss....". Sometimes it's anti-C++ because "object orientation is all about mutable state and mutability is the root of all evil.".

What's been most entertaining for me listening to and having a number of these arguments, whether in person, or on the internets, is that I think I've isolated a fairly fundamental axiomatic difference that frequently drives these conversation straight off the cliff. 

Let me make some absurdly reductionist claims.

In any given programming language (or technology), there are exactly two kindws of programmers: the **experienced** and the **inexperienced**. I'm using a fairly high bar for "experienced" programmers throughout this post. Knowing the language well isn't quite enough, you also need to *get* the language on a deeper level. You need to understand how the language wants you to do things, and when and where its idiomatic to use a feature of the language. Not only knowing the whole language well, but also having a strong sense of code being "pythonic" might be a reasonable definition of an experienced python programmer. 

All programmers, experienced and inexperienced alike, have **good days** and **bad days**. Please note, the actual unit of time is irrelevant (we might also say good lines of code, and bad lines of code). FWIW, I've carefully chosen units of time instead of the skill of programmers. Very often "in the wild" these exact arguments are frames as "good vs bad" programmers which poisons shit beyond belief (and often heads into comical strawmen).

A **good day** is stronger than just writing bug free code. Your design is solid, your code is as idiomatic as it can be, utilizating everything the language provides, as well as being totally bug free. A **bad day** is, of course, when any of these things start to slip.

So there are 4 situations where any of us might find ourselves in on a given day:

1. **Inexperienced, and having a bad day**. Your code is wrong, you don't know why. You are writing code you barely understand and creating bugs you definitely don't. You are learning. The programming language is being judged on its traps, documentation, tutorials, error messages, and the ease at which newbies fall into holes in any of this.
2. **Inexperienced, and having a good day**. You are writing code as correct, idiomatic as you can. You don't know enough to make it -perfect- so it's probably not optimal in some way, but it's going to work, and this isn't the singular most important piece of code in the codebase. Your programming language is being judged on how productive it makes the vast army of journeyman and profressional programmers sitting here. Most of the value created by programmers is created on these days.
3. **Experienced, and having a bad day**. You are writing the most important code in the project and you are screwing it up. Your either making a bad design that we'll spend months fixing later, or you're doing something and you -clearly- know better. You're going to be mad at yourself later. When the language is running close to its limit, with all of its features coming together, how forgiving is it? How much can it protect us? Your code is going to be judged by it's entire tooling ecosystem, all of its ability to prevent bugs and make debugging easier, and all the tools it has to fix huge messes (refactoring, debuggers, etc.)
4. **Experienced, and having a good day**. You are writing the most important piece of logic in a billion dollar program. Your design is right. It's perfectly optimal and bug free. It doesn't even need tests because of its self-evident magic. You changed the course of an entire company today, maybe an industry. You go home by 5pm. Your programming language is being judged at what's the best possible outcome. How high is the ceiling. 

Here's my claim: essentially all programming language arguments that go sideways do so because two people are talking about different sections of this matrix. 

Some languages that cause arguments and how this applies.

static vs dynamic typing. This one is a bit more complicated than a paragraph can allow so let's see how I do. Many arguments in favor of dynamic typing sit squarely in the producitivity category (inexperienced programmers having good days) where huge amounts of business value can be created relatively easy. Most static typing arguments are talking about the other three squares. Namely, 1) on your bad days, the compiler can help alot more and 2) dynamic typing limits the best-possible-program in ways that are unacceptable. 

Garbage collection. 

Haskell. Haskell has this huge, principled and sophisticated type system. The treatment of inexperienced & experienced engineers on their bad days is very different. Newbies get brutalized but experienced engineers get -tremendous- value. ("oh! duh! it's just that old monomorphism restriction.. I'm such a newb").

C++. Essentially every argument against C++ focuses on the bad days. It doesn't protect you at all. Template error messages. Huge complexity that you constantly need to hold in your head. There's no one, including its supporters, that can say C++ is as good as it could be for those bad days. That said, essentially every defense of C++ is focused on those good days. They can all be essentially boiled down into: "once I get this right, my code will be at least one of faster, more generic, and safer than language X can ever reasonably produce". By safer, here, remembnering my code is perfect, I mean abstractions that are harder to misuse. For example, this is essentially the argument C++ programmers and those associated domains make against garbage collected languages.  
